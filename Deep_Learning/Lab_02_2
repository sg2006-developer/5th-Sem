import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

class Perceptron:
    def __init__(self, lr, epochs=100):
        self.lr = lr
        self.epochs = epochs
        self.weights = None
        self.bias = None
        
    def fit(self, X, y):
        n_samples, n_features = X.shape
        self.weights = np.zeros(n_features)
        self.bias = 0.0
        
        for epoch in range(self.epochs):
            for i in range(n_samples):
                y_pred = self.predict(X[i])
                error = y[i]-y_pred
                
                self.weights += self.lr * error * X[i]
                self.bias += self.lr * error
                
    def predict(self, x):
        weighted_sum = np.dot(x, self.weights)+self.bias
        return weighted_sum
        
X_train = np.array([[2,3], [3,4], [2,7], [5,7],[4,7]])
y_train = np.array([12,24,28,70,56])

plt.scatter(X_train[:,0], X_train[:,1], c=y_train)
plt.show()

perceptron = Perceptron(lr=0.01)
perceptron.fit(X_train, y_train)
print(perceptron.predict([100,300]))

x_values = np.array([X_train[:,0].min() - 1, X_train[:,0].max()+1])
y_values = (-perceptron.weights[0]*x_values-perceptron.bias)/perceptron.weights[1]

# plt.scatter(X_train[:,0], X_train[:,1], c=y_train)
# plt.plot(x_values, y_values, 'k--')
# plt.xlabel("Feature 1")
# plt.ylabel("Feature 2")
# plt.title("Perceptron Decision Boundary")
# plt.ylim([X_train[:,1].min()-1, X_train[:,1].max()+1])
# plt.show()
